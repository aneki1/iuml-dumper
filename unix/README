This requires a Solaris machine with iUML 2.2.0 installed to build and run. It has been successfully compiled and run on SunOS 5.10, with the "Sun C++ 5.9 SunOS-Sparc" CC compiler.
You will also need to install cmake (www.cmake.org) and the Boost header files (www.boost.org). To my knowledge there are no binary versions of cmake for Solaris, but it builds from source without problems by following their instructions. There is no need to build boost if you don't want, as only the headers are required. The CC compiler we use is fairly prehistoric, and later versions of Boost will not compile - we use 1.51.0, and I think they stopped supporting SunOS 5.10 with 1.52.

You may get some joy with installing a better compiler, or cross-compiling from Linux, but I haven't tried that, and as you will see below, the iUML API seems to be quite sensitive to the way it is built!

There is a patch file iuml.patch, which needs to be applied to the installation of iUML. (Note that it will probably only work on 2.2.0 - if you are using a different version then you may need to adjust accordingly) This fixes various bugs with the API (which mostly appear to stem from when they converted from Shlaer-Mellor to UML terminology missed converting a lot of terms in the API), but also extends the API to allow navigation along relationships which weren't exposed in the API, and extends the functionality of the iUML tool itself to allow the same tag to be applied multiple times. 

We have had a beta version of iUML 2.3 which appears to have taken at least some of the patches above onboard (to the extent that they call my invented relationship to supplementary code blocks R999 as I do!), so that may just work without patching, but we have not used this in anger. If I remember correctly (from 2008!) there were some patches that were still needed, but files were arranged differently so I didn't put any effort into getting it working in lieu of a non-beta version which never arrived!

Once the patch has been applied, set the environment variable UML_ROOT to point to your installation and build as follows...

$ source iuml-dumper/setupenv.sh
$ mkdir build
$ cd build
$ cmake ../iuml-dumper
$ make install

As usual with cmake, the installation directory can be specified to the cmake command with -DCMAKE_INSTALL_PREFIX=<xxx>, and the path to Boost with -DBOOST_ROOT=<xxx> if it is not installed in a standard path.

That should build you (amongst other things) the UMLDumpModel executable. Note that setupenv.sh must have been run before running the executable. Running with no arguments will print usage information.

The code is split into three main areas
The API Generator - this is an executable which parses the output from the iUML generated domain model of the OOAofOOA, (with some edits and handcrafted extra files) to generate a C++ wrapper around the C API.
The C++ API - this is mostly generated by the above, but with a few 'extras' thrown in.
The actual Dumper, which uses the C++ API to run around the model and write out the MASL.

There are a few gotchas to look out for...

The Rogue Wave version of the C++ standard library that comes with our compiler thinks that the compiler doesn't support member templates, but it actually does, so there is a stdcomp.h file in the include directory to force this. You may not need this if you are using a better compiler.
It doesn't seem to run properly if built in cmake Release mode (ie with the optimizer on) - it Seg Faults somewhere in the standard library. This doesn't happen on our production version in clearcase, so I can only assume there is some subtlety with link orders or something, but I can't seem to find it - everything looks identical to me! Everything works fine with the cmake default build type, and with Debug.
The iUML library libC.so defines and uses a clog symbol, which is also defined (differently) in libm.so, so to force the linker to use the correct (libC) version we have to force libC into the link line first. It will Seg Fault if this is not done.

If you are looking to write other tools to extract info from iUML, then you probably want to build on top of the C++ iUMLAPI library. The UMLDumpModel and UMLUpdateModel are the most extensive examples, but there are a few other tools in the utils directory which show how to do other bits and pieces.

